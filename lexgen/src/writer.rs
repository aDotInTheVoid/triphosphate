use std::collections::{BTreeMap, BTreeSet};

use camino::{Utf8Path, Utf8PathBuf};
use fs_err as fs;
use proc_macro2::TokenStream;

use crate::compiller::{ItemPath, Mod};

#[derive(Debug, Default)]
struct File {
    mods: BTreeSet<String>,
    item: Vec<TokenStream>,
}

#[derive(Debug, Default)]
struct Files {
    files: BTreeMap<Utf8PathBuf, File>,
}

pub(super) fn write_to(base: &Utf8Path, contents: &BTreeMap<ItemPath, TokenStream>) {
    let mut files = Files::default();

    for (path, item) in contents {
        files.add_item(path, item.clone());
    }

    for (path, file) in files.files {
        let path = base.join(path);

        let contents = file.contents();

        fs::create_dir_all(path.parent().unwrap()).unwrap();

        fs::write(path, contents).unwrap();
    }
}

impl Files {
    fn add_item(&mut self, path: &ItemPath, item: TokenStream) {
        let file = self.create_mod(&path.0);

        file.item.push(item);
    }

    fn create_mod(&mut self, m: &Mod) -> &mut File {
        let path = &m.0;

        for i in 0..path.len() {
            let i = i + 1;
            let components = &path[..i];
            let path = path_for(components);
            self.files.entry(path).or_default();
            self.link_mod(&components[..i - 1], &components[i - 1]);
        }

        let path = path_for(&path);
        self.files.get_mut(&path).unwrap()
    }

    fn link_mod(&mut self, components: &[String], mod_: &str) {
        let file = if components.is_empty() {
            Utf8Path::new("mod.rs").to_owned()
        } else {
            path_for(components)
        };

        self.files
            .entry(file)
            .or_default()
            .mods
            .insert(mod_.to_owned());
    }
}

impl File {
    fn contents(&self) -> String {
        let mut contents = String::new();

        contents.push_str("// Code generated by triphosphate lexgen. DO NOT EDIT.\n");

        for m in &self.mods {
            contents.push_str(&format!("pub mod {};\n", m));
        }

        contents.push_str("\n");

        for item in &self.item {
            contents.push_str(&item.to_string());
            contents.push_str("\n");
        }

        contents
    }
}

fn path_for(components: &[String]) -> Utf8PathBuf {
    let mut path = Utf8PathBuf::new();
    for c in components {
        path.push(c);
    }
    path.set_extension("rs");
    path
}

#[cfg(test)]
mod tests {
    use super::*;

    fn s(s: &str) -> String {
        s.to_owned()
    }
    fn ss(s: &[&str]) -> Vec<String> {
        s.into_iter().map(|s| s.to_string()).collect()
    }
    fn p(s: &str) -> &Utf8Path {
        Utf8Path::new(s)
    }
    fn bs(s: &[&str]) -> BTreeSet<String> {
        s.into_iter().map(|s| s.to_string()).collect()
    }

    #[test]
    fn test_path_for() {
        #[track_caller]
        fn check(components: &[String], expected: &str) {
            let path = path_for(components);
            assert_eq!(path, expected);
        }

        check(&ss(&["foo", "bar"]), "foo/bar.rs");
        check(&ss(&["foo", "bar", "baz"]), "foo/bar/baz.rs");
        check(&[], ""); // lol
    }

    #[test]
    fn test_create_mod() {
        let mut files = Files::default();

        files.create_mod(&Mod(ss(&["foo", "bar", "baz"])));

        assert_eq!(files.files.len(), 4);
        assert_eq!(files.files[p("mod.rs")].mods, bs(&["foo"]));
        assert_eq!(files.files[p("foo.rs")].mods, bs(&["bar"]));
        assert_eq!(files.files[p("foo/bar.rs")].mods, bs(&["baz"]));
        assert_eq!(files.files[p("foo/bar/baz.rs")].mods, bs(&[]));

        files.create_mod(&Mod(ss(&["foo", "bar", "qux"])));

        assert_eq!(files.files.len(), 5);
        assert_eq!(files.files[p("mod.rs")].mods, bs(&["foo"]));
        assert_eq!(files.files[p("foo.rs")].mods, bs(&["bar"]));
        assert_eq!(files.files[p("foo/bar.rs")].mods, bs(&["baz", "qux"]));
        assert_eq!(files.files[p("foo/bar/baz.rs")].mods, bs(&[]));
        assert_eq!(files.files[p("foo/bar/qux.rs")].mods, bs(&[]));
    }
}
