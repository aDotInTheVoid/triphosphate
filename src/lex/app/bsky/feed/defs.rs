// Code generated by triphosphate lexgen. DO NOT EDIT.

#[allow(unused_imports)]
use super::super::super::super::_lex;
#[derive(
    ::std::fmt::Debug,
    ::std::clone::Clone,
    ::serde::Deserialize,
    ::serde::Serialize,
    ::libipld::DagCbor,
)]
pub struct BlockedAuthor {
    pub did: _lex::_rt::Did,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub viewer: Option<_lex::app::bsky::actor::defs::ViewerState>,
}
impl _lex::_rt::LexItem for BlockedAuthor {
    const URI: &'static str = "app.bsky.feed.defs#blockedAuthor";
}

#[derive(
    ::std::fmt::Debug,
    ::std::clone::Clone,
    ::serde::Deserialize,
    ::serde::Serialize,
    ::libipld::DagCbor,
)]
pub struct BlockedPost {
    pub author: _lex::app::bsky::feed::defs::BlockedAuthor,
    pub blocked: bool,
    pub uri: _lex::_rt::AtUri,
}
impl _lex::_rt::LexItem for BlockedPost {
    const URI: &'static str = "app.bsky.feed.defs#blockedPost";
}

#[derive(
    ::std::fmt::Debug,
    ::std::clone::Clone,
    ::serde::Deserialize,
    ::serde::Serialize,
    ::libipld::DagCbor,
)]
pub struct FeedViewPost {
    pub post: _lex::app::bsky::feed::defs::PostView,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub reason: Option<()>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub reply: Option<_lex::app::bsky::feed::defs::ReplyRef>,
}
impl _lex::_rt::LexItem for FeedViewPost {
    const URI: &'static str = "app.bsky.feed.defs#feedViewPost";
}

#[derive(
    ::std::fmt::Debug,
    ::std::clone::Clone,
    ::serde::Deserialize,
    ::serde::Serialize,
    ::libipld::DagCbor,
)]
pub struct GeneratorView {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub avatar: Option<::std::string::String>,
    pub cid: _lex::_rt::Cid,
    pub creator: _lex::app::bsky::actor::defs::ProfileView,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<::std::string::String>,
    #[serde(rename = "descriptionFacets")]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description_facets: Option<Vec<_lex::app::bsky::richtext::Facet>>,
    pub did: _lex::_rt::Did,
    #[serde(rename = "displayName")]
    pub display_name: ::std::string::String,
    #[serde(rename = "indexedAt")]
    pub indexed_at: _lex::_rt::Datetime,
    #[serde(rename = "likeCount")]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub like_count: Option<u64>,
    pub uri: _lex::_rt::AtUri,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub viewer: Option<_lex::app::bsky::feed::defs::GeneratorViewerState>,
}
impl _lex::_rt::LexItem for GeneratorView {
    const URI: &'static str = "app.bsky.feed.defs#generatorView";
}

#[derive(
    ::std::fmt::Debug,
    ::std::clone::Clone,
    ::serde::Deserialize,
    ::serde::Serialize,
    ::libipld::DagCbor,
)]
pub struct GeneratorViewerState {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub like: Option<_lex::_rt::AtUri>,
}
impl _lex::_rt::LexItem for GeneratorViewerState {
    const URI: &'static str = "app.bsky.feed.defs#generatorViewerState";
}

#[derive(
    ::std::fmt::Debug,
    ::std::clone::Clone,
    ::serde::Deserialize,
    ::serde::Serialize,
    ::libipld::DagCbor,
)]
pub struct NotFoundPost {
    #[serde(rename = "notFound")]
    pub not_found: bool,
    pub uri: _lex::_rt::AtUri,
}
impl _lex::_rt::LexItem for NotFoundPost {
    const URI: &'static str = "app.bsky.feed.defs#notFoundPost";
}

#[derive(
    ::std::fmt::Debug,
    ::std::clone::Clone,
    ::serde::Deserialize,
    ::serde::Serialize,
    ::libipld::DagCbor,
)]
pub struct PostView {
    pub author: _lex::app::bsky::actor::defs::ProfileViewBasic,
    pub cid: _lex::_rt::Cid,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub embed: Option<()>,
    #[serde(rename = "indexedAt")]
    pub indexed_at: _lex::_rt::Datetime,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<Vec<_lex::com::atproto::label::defs::Label>>,
    #[serde(rename = "likeCount")]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub like_count: Option<i64>,
    pub record: _lex::_rt::Unknown,
    #[serde(rename = "replyCount")]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub reply_count: Option<i64>,
    #[serde(rename = "repostCount")]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repost_count: Option<i64>,
    pub uri: _lex::_rt::AtUri,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub viewer: Option<_lex::app::bsky::feed::defs::ViewerState>,
}
impl _lex::_rt::LexItem for PostView {
    const URI: &'static str = "app.bsky.feed.defs#postView";
}

#[derive(
    ::std::fmt::Debug,
    ::std::clone::Clone,
    ::serde::Deserialize,
    ::serde::Serialize,
    ::libipld::DagCbor,
)]
pub struct ReasonRepost {
    pub by: _lex::app::bsky::actor::defs::ProfileViewBasic,
    #[serde(rename = "indexedAt")]
    pub indexed_at: _lex::_rt::Datetime,
}
impl _lex::_rt::LexItem for ReasonRepost {
    const URI: &'static str = "app.bsky.feed.defs#reasonRepost";
}

#[derive(
    ::std::fmt::Debug,
    ::std::clone::Clone,
    ::serde::Deserialize,
    ::serde::Serialize,
    ::libipld::DagCbor,
)]
pub struct ReplyRef {
    pub parent: (),
    pub root: (),
}
impl _lex::_rt::LexItem for ReplyRef {
    const URI: &'static str = "app.bsky.feed.defs#replyRef";
}

#[derive(
    ::std::fmt::Debug,
    ::std::clone::Clone,
    ::serde::Deserialize,
    ::serde::Serialize,
    ::libipld::DagCbor,
)]
pub struct SkeletonFeedPost {
    pub post: _lex::_rt::AtUri,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub reason: Option<()>,
}
impl _lex::_rt::LexItem for SkeletonFeedPost {
    const URI: &'static str = "app.bsky.feed.defs#skeletonFeedPost";
}

#[derive(
    ::std::fmt::Debug,
    ::std::clone::Clone,
    ::serde::Deserialize,
    ::serde::Serialize,
    ::libipld::DagCbor,
)]
pub struct SkeletonReasonRepost {
    pub repost: _lex::_rt::AtUri,
}
impl _lex::_rt::LexItem for SkeletonReasonRepost {
    const URI: &'static str = "app.bsky.feed.defs#skeletonReasonRepost";
}

#[derive(
    ::std::fmt::Debug,
    ::std::clone::Clone,
    ::serde::Deserialize,
    ::serde::Serialize,
    ::libipld::DagCbor,
)]
pub struct ThreadViewPost {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub parent: Option<()>,
    pub post: _lex::app::bsky::feed::defs::PostView,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub replies: Option<Vec<()>>,
}
impl _lex::_rt::LexItem for ThreadViewPost {
    const URI: &'static str = "app.bsky.feed.defs#threadViewPost";
}

#[derive(
    ::std::fmt::Debug,
    ::std::clone::Clone,
    ::serde::Deserialize,
    ::serde::Serialize,
    ::libipld::DagCbor,
)]
pub struct ViewerState {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub like: Option<_lex::_rt::AtUri>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub repost: Option<_lex::_rt::AtUri>,
}
impl _lex::_rt::LexItem for ViewerState {
    const URI: &'static str = "app.bsky.feed.defs#viewerState";
}
